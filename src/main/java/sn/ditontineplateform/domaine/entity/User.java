package sn.ditontineplateform.domaine.entity;import jakarta.persistence.CascadeType;import jakarta.persistence.Column;import jakarta.persistence.Entity;import jakarta.persistence.FetchType;import jakarta.persistence.OneToMany;import jakarta.persistence.OneToOne;import jakarta.persistence.Table;import jakarta.persistence.UniqueConstraint;import jakarta.validation.constraints.DecimalMax;import jakarta.validation.constraints.DecimalMin;import jakarta.validation.constraints.Email;import jakarta.validation.constraints.Min;import jakarta.validation.constraints.NotBlank;import jakarta.validation.constraints.Past;import jakarta.validation.constraints.Pattern;import jakarta.validation.constraints.Size;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.ToString;import org.hibernate.annotations.JdbcTypeCode;import org.hibernate.type.SqlTypes;import java.math.BigDecimal;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;/** * Entité représentant un utilisateur de la plateforme DiTontine. Contient les informations personnelles, les * préférences et les données financières. * * @author DiTontine Team * @version 1.0 * @since 2025-01-01 */@Data@EqualsAndHashCode(callSuper = true, exclude = {"participations", "tontinesAdministrees", "notifications", "coffre", "transactionsCoffre"})@ToString(callSuper = true, exclude = {"participations", "tontinesAdministrees", "notifications", "coffre", "transactionsCoffre"})@Entity@Table(        name = "users", uniqueConstraints = {        @UniqueConstraint(columnNames = "email"),        @UniqueConstraint(columnNames = "telephone")})public class User extends BaseEntity {    /**     * Nom complet de l'utilisateur. Doit contenir entre 2 et 100 caractères. Ce champ est obligatoire.     */    @NotBlank(message = "Le nom complet est requis")    @Size(min = 2, max = 100, message = "Le nom doit contenir entre 2 et 100 caractères")    @Column(name = "full_name", nullable = false)    private String fullName;    /**     * Adresse email unique de l'utilisateur.     */    @NotBlank(message = "L'email ne peut pas être vide")    @Email(message = "Format d'email invalide")    @Column(name = "email", nullable = false, unique = true, length = 100)    private String email;    /**     * Numéro de téléphone unique de l'utilisateur.     */    @NotBlank(message = "Le téléphone ne peut pas être vide")    @Pattern(regexp = "^(\\+221|00221)?[0-9]{9}$", message = "Format de téléphone invalide")    @Column(name = "telephone", nullable = false, unique = true, length = 20)    private String telephone;    /**     * Mot de passe chiffré de l'utilisateur.     */    @NotBlank(message = "Le mot de passe ne peut pas être vide")    @Size(min = 8, message = "Le mot de passe doit contenir au moins 8 caractères")    @Column(name = "mot_de_passe", nullable = false)    private String motDePasse;    /**     * Date de naissance de l'utilisateur.     */    @Past(message = "La date de naissance doit être dans le passé")    @Column(name = "date_naissance")    private LocalDate dateNaissance;    /**     * Indicateur si l'utilisateur est actif.     */    @Column(name = "is_active", nullable = false)    private Boolean isActive = true;    /**     * Indicateur si l'email est vérifié.     */    @Column(name = "email_verified", nullable = false)    private Boolean emailVerified = false;    /**     * Numéro d'identification national (CNI, passeport, etc.).     */    @Size(min = 5, max = 50, message = "L'identifiant national doit contenir entre 5 et 50 caractères")    @Column(name = "national_id", unique = true)    private String nationalId;    /**     * Indique si le téléphone a été vérifié. Par défaut à false.     */    @Column(name = "phone_verified")    private Boolean phoneVerified = false;    /**     * Profession de l'utilisateur. Limitée à 100 caractères maximum.     */    @Size(max = 100, message = "La profession ne peut excéder 100 caractères")    @Column(name = "profession")    private String profession;    /**     * Identifiant Keycloak pour l'authentification.     */    @Column(name = "keycloak_id", unique = true)    private String keycloakId;    /**     * URL de l'image de profil.     */    @Column(name = "profile_image_url")    private String profileImageUrl;    /**     * Langue préférée de l'utilisateur. Par défaut à "fr".     */    @Column(name = "preferred_language", length = 2)    private String preferredLanguage = "fr";    /**     * Liste des rôles de l'utilisateur. Stockée sous forme JSON dans la base de données.     */    @JdbcTypeCode(SqlTypes.JSON)    @Column(name = "roles", columnDefinition = "jsonb")    private List<String> roles = new ArrayList<>();    /**     * Date et heure de la dernière connexion.     */    @Column(name = "last_login_at")    private LocalDateTime lastLoginAt;    /**     * Score de ponctualité de l'utilisateur (0-100).     */    @DecimalMin(value = "0.0", message = "Le score de ponctualité ne peut pas être négatif")    @DecimalMax(value = "100.0", message = "Le score de ponctualité ne peut pas dépasser 100")    @Column(name = "score_ponctualite", precision = 5, scale = 2)    private BigDecimal scorePonctualite = BigDecimal.valueOf(100.0);    /**     * Nombre de tontines complétées par l'utilisateur.     */    @Min(value = 0, message = "Le nombre de tontines complétées ne peut pas être négatif")    @Column(name = "tontines_completees", nullable = false)    private Integer tontinesCompletees = 0;    /**     * Préférences de notifications de l'utilisateur.     */    @Column(name = "notifications_enabled", nullable = false)    private Boolean notificationsEnabled = true;    /**     * Préférences de rappels de cotisation.     */    @Column(name = "rappels_cotisation_enabled", nullable = false)    private Boolean rappelsCotisationEnabled = true;    /**     * Préférences de newsletter.     */    @Column(name = "newsletter_enabled", nullable = false)    private Boolean newsletterEnabled = true;    /**     * Adresse physique de l'utilisateur.     */    @Size(max = 200, message = "L'adresse ne peut pas dépasser 200 caractères")    @Column(name = "adresse", length = 200)    private String adresse;    /**     * Ville de résidence de l'utilisateur.     */    @Size(max = 50, message = "La ville ne peut pas dépasser 50 caractères")    @Column(name = "ville", length = 50)    private String ville;    /**     * Pays de résidence de l'utilisateur.     */    @Size(max = 50, message = "Le pays ne peut pas dépasser 50 caractères")    @Column(name = "pays", length = 50)    private String pays = "Sénégal";    /**     * Participations de l'utilisateur aux tontines.     */    @OneToMany(mappedBy = "participant", fetch = FetchType.LAZY, cascade = CascadeType.ALL)    private Set<Participation> participations = new HashSet<>();    /**     * Tontines administrées par l'utilisateur.     */    @OneToMany(mappedBy = "administrateur", cascade = CascadeType.ALL, fetch = FetchType.LAZY)    private Set<Tontine> tontinesAdministrees = new HashSet<>();    /**     * Notifications de l'utilisateur.     */    @OneToMany(mappedBy = "utilisateur", cascade = CascadeType.ALL, fetch = FetchType.LAZY)    private Set<Notification> notifications = new HashSet<>();    /**     * Coffre personnel de l'utilisateur.     */    @OneToOne(mappedBy = "proprietaire", cascade = CascadeType.ALL, fetch = FetchType.LAZY)    private Coffre coffre;    /**     * Transactions du coffre de l'utilisateur.     */    @OneToMany(mappedBy = "utilisateur", cascade = CascadeType.ALL, fetch = FetchType.LAZY)    private Set<TransactionCoffre> transactionsCoffre = new HashSet<>();    /**     * Génère les initiales de l'utilisateur.     *     * @return les initiales (ex: "JD" pour "John Doe")     */    public String getInitials () {        if (fullName == null || fullName.trim().isEmpty()) {            return "";        }        String[] names = fullName.split(" ");        if (names.length == 0) return "";        if (names.length == 1) return names[0].substring(0, 1).toUpperCase();        return (names[0].charAt(0) + names[names.length - 1].substring(0, 1)).toUpperCase();    }    /**     * Calcule l'âge de l'utilisateur en années.     *     * @return l'âge en années ou null si la date de naissance n'est pas renseignée     */    public Integer getAge () {        if (dateNaissance == null) return null;        return Period.between(dateNaissance, LocalDate.now()).getYears();    }    /**     * Vérifie si l'utilisateur est majeur.     *     * @return true si l'utilisateur a 18 ans ou plus, false sinon     */    public Boolean isAdult () {        Integer age = getAge();        return age != null && age >= 18;    }    /**     * Vérifie si l'utilisateur est complètement vérifié (email et téléphone).     *     * @return true si l'utilisateur est vérifié, false sinon     */    public Boolean isFullyVerified () {        return Boolean.TRUE.equals(emailVerified) && Boolean.TRUE.equals(phoneVerified);    }    /**     * Vérifie si l'utilisateur peut participer à une tontine.     *     * @return true si l'utilisateur est actif et son email est vérifié     */    public boolean peutParticiperATontine () {        return isActive && emailVerified;    }    /**     * Vérifie si l'utilisateur peut administrer une tontine.     *     * @return true si l'utilisateur peut participer et a un bon score de ponctualité     */    public boolean peutAdministrerTontine () {        return peutParticiperATontine() && scorePonctualite.compareTo(BigDecimal.valueOf(70.0)) >= 0;    }}